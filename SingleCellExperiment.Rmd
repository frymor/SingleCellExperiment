---
title: "SingleCellExperiment"
author: "AY"
date: "5/20/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

---
title: "Orchestrating Single-Cell Analysis with Bioconductor"
output: html_notebook
---

### Needed packages

```{r, message=FALSE}
# BiocManager::install("SingleCellExperiment")
# BiocManager::install(c("scater", "scran", "uwot"))

library(SingleCellExperiment)
```

# The `sce` Object:

![Figure 1. Overview of the SingleCellExperiment object](images/singlecellexperiment.png)

## Primary Data: The `assays` Slot



```{r}
counts_matrix <- data.frame(cell_1 = rpois(10, 10), 
                    cell_2 = rpois(10, 10), 
                    cell_3 = rpois(10, 30))
rownames(counts_matrix) <- paste0("gene_", 1:10)
counts_matrix <- as.matrix(counts_matrix) # must be a matrix object!
```


From this, we can now construct our first SingleCellExperiment object, using the defined constructor, SingleCellExperiment(). Note that we provide our data as a named list, and each entry of the list is a matrix. Here, we name the counts_matrix entry as simply counts within the list.

```{r}
sce <- SingleCellExperiment(assays = list(counts = counts_matrix))
sce
```

To access the count data we just supplied, we can do any one of the following:

`assay(sce, "counts")` - this is the most general method, where we can supply the name of the assay as the second argument.
`counts(sce)` - this is the same as the above, but only works for assays with the special name "counts".


```{r}
assay(sce, "counts")
```

### Extending the assays Slot

the assay slot can hold multiple representations of the primary data, certain slots expect numeric matrices, whereas others may expect data frames.

```{r}
sce <- scran::computeSumFactors(sce)
sce <- scater::normalize(sce)
sce
```

### Column (Meta)Data: `colData` Slot

To further annotate our sce object, one of the first and most useful pieces of information is adding on metadata that describes the columns of our primary data, e.g. describing the samples or cells of our experiment. This data is entered into the `colData` slot:

```{r}
cell_metadata <- data.frame(batch = c(1, 1, 2))
rownames(cell_metadata) <- paste0("cell_", 1:3)
```

```{r}
## From scratch:
sce <- SingleCellExperiment(assays = list(counts = counts_matrix),
                           colData = cell_metadata)

## Appending to existing object (requires DataFrame() coercion)
# colData(sce) <- DataFrame(cell_metadata)
```

```{r}
sce <- scater::calculateQCMetrics(sce)
```

#### Using colData for Subsetting
A common operation with colData is its use in subsetting. One simple way to access colData is through the use of the $ operator, which is a shortcut for accessing a variable within the colData slot:

```{r}
sce$batch
```
## [1] 1 1 2
## colData(sce)$batch # same as above
If we only wanted cells within batch 1, we could subset our sce object as follows (remember, we subset on the columns in this case because we are filtering by cells/samples here).

```{r}
sce[, sce$batch == 1]
```

### Feature Metadata: rowData/rowRanges

Lastly, the rows also have their own metadata slot to store information that pertains to the features of the sce object:

* `rowData` slot: contains data in a `data.frame` (DataFrame) format that describes aspects of the data corresponding to the rows of the primary data (Figure 1A, green box).
Furthermore, there is a special slot which pertains to features with genomic coordinates:

* `rowRanges` slot: contains data in a `GRangesList` (where each entry is a `GenomicRanges` format) that describes the chromosome, start, and end coordinates of the features (genes, genomic regions).
Both of these can be accessed via their respective accessors, rowRanges() and rowData(). In our case, rowRanges(sce) produces an empty list:

```{r}
rowRanges(sce)  # empty
rowData(sce)[, 1:3] # results from the calculateQCMetrics(sce)
```

#### Subsetting with on Rows
To subset an sce object down at the feature/gene level, we can do a row subsetting operation similar to other R objects, by supplying either numeric indices or a vector of names:

```{r}
sce[c("gene_1", "gene_4"), ]
```

### Size Factors Slot: sizeFactors
Briefly, we already encountered this via the scran::computeSumFactors(sce) call, which adds a sizeFactors slot:

sizeFactors slot: contains information in a numeric vector regarding the sample/cell normalization factors used to produce a normalize data representation (Figure 1B, brown box)

```{r}
sce <- scran::computeSumFactors(sce)
sce <- scater::normalize(sce)
sizeFactors(sce)
```




















